#!/usr/bin/env python3
"""WARNING: Your targets/baits files may need pre-processing!

    The intervals here should be compatible with the reference you are planning
    to use. That means the sequence names (first column) must match the refdict
    sequence names (SN field). AND The start/stop coordinates must fall
    inside the sequence lengths described by the refdict (LN field).

    Additionally, padding is added to the targets when creating the filter
    files. It is not included in the Picard metrics files. The targets intervals
    do NOT need to be padded before starting this process.

Summary:

The goal of this script is to generate the files needed to add a new capture
kit to the TGen pipeline. Three types of files will need to be created:

    Picard .interval_list

    These are used for Picard metrics modules and describe the locations
    targetted by the capture kit. Coverage metrics generated by the pipeline
    will be relative to the regions defined in these files. There is one
    '.interval_list' for the targets and one for the baits. If baits is
    not given, both files will be generated from the targets.
    https://gatkforums.broadinstitute.org/gatk/discussion/1319/collected-faqs-about-interval-lists
    http://broadinstitute.github.io/picard/command-line-overview.html#BedToIntervalList


    VCF merger filter .bed

    This is a bed file that describes the locations to include in the final
    merged VCF. This file is generated by extending regions in the targets
    intervals file for a more comprehensive filter. This file includes a union
    of the following intervals:

        A) padded_targets: target intervals file padded by 100bp
        B) exon_bed: Exonic intervals that intersect any "A" interval


    CNA index .bed

    This file is an index for tCoNut, in bed format, which describes the
    targeted regions in 100bp intervals. This is generated by intersecting
    a template bed file with the VCF merger filter .bed. The result is kind of
    an index file that describes the locations covered by the kit, in 100bp
    increments.



Glossary:

    Targets

    Also called "regions" or "target regions". This is a file that describes the
    regions that the exome kit aims to capture. This is usually distributed by
    the manufacturer of the kit as a .bed file. It may need some pre-processing
    before starting this application.

    https://www.ensembl.org/info/website/upload/bed.html

    Baits

    Also called "probes". This is a file that describes the hybrid capture
    probes in the kit. This is usually distributed by the manufacturer of the
    kit as a .bed file. It may need some pre-processing before starting this
    application.


"""
import os
import tempfile
import pkg_resources
import subprocess
import logging
import argparse

from jetstream.formats.refdict import refdict_to_bedtools_genome
from jetstream.formats import intervals

log = logging.getLogger(__name__)

PICARD_PATH = pkg_resources.resource_filename('jetstream', 'plugins/picard.jar')
BEDTOOLS = 'bedtools'


def parse_args(args=None):
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description="Generate a reference pack for a new exome kit. See epilog "
                    "for detailed usage instructions.",
        epilog=__doc__
    )

    parser.add_argument(
        '-t', '--targets',
        required=True,
        help='Path to the targets bed file.'
    )

    parser.add_argument(
        '-b', '--baits',
        help='Path to a baits bed file. This file is optional.'
      )

    parser.add_argument(
        '-g', '--gtf',
        required=True,
        help='Path to a reference GTF'
    )

    parser.add_argument(
        '-r', '--refdict',
        required=True,
        help="Path to the reference dictionary"
    )

    parser.add_argument(
        '-c', '--cna-template',
        default='/home/tgenref/binaries/capture_specific_jetstream_file_creation/Copy_Number_100bp_Interval_Template.bed',
        help="Path to the CNA template bed file. "
        # TODO: This should be replaced in the future with code that
        # that generates the template from a given refdict
    )

    args = parser.parse_args(args)
    return args


def check_java_version():
    subprocess.check_call(['java', '-version'])


class DeconstructedPath:
    def __init__(self, path):
        self.path = path
        self.size = os.path.getsize(path)  # This also verifies the path exists
        self.dir = os.path.dirname(path)
        self.base = os.path.basename(path)
        self.root, self.ext = os.path.splitext(self.base)


def make_picard_intervals_list(bed, refdict):
    """ Starts a Picard BedToIntervalList process and returns tempfile """
    check_java_version()

    cmd_args = [
        'java',
        '-jar',
        PICARD_PATH,
        'BedToIntervalList',
        'I=' + bed,
        'O=/dev/stdout',
        'SD=' + refdict,
    ]

    log.debug('Starting Picard: {}'.format(' '.join(cmd_args)))

    temp = tempfile.NamedTemporaryFile()
    picard = subprocess.Popen(cmd_args, stdout=temp)
    picard.wait()

    if picard.returncode != 0:
        raise ChildProcessError(' '.join(picard.args))

    return temp


def bedtools_intersect(a, b):
    """ Returns a tempfile that includes all intervals in a which intersect
    any interval in b. """
    cmd_args = [
        BEDTOOLS,
        'intersect',
        '-header',
        '-wa',
        '-a', a,
        '-b', b
    ]

    log.debug('Starting Bedtools intersect: {}'.format(' '.join(cmd_args)))

    temp = tempfile.NamedTemporaryFile()
    bedtools = subprocess.Popen(cmd_args, stdout=temp)
    bedtools.wait()

    if bedtools.returncode != 0:
        raise ChildProcessError(' '.join(bedtools.args))

    return temp


def bedtools_merge(a):
    cmd_args_sort = [
        BEDTOOLS,
        'sort',
        '-header',
        '-i', a
    ]

    log.debug('Starting Bedtools sort: {}'.format(' '.join(cmd_args_sort)))

    bedtools_sort = subprocess.Popen(cmd_args_sort, stdout=subprocess.PIPE)

    cmd_args = [
        BEDTOOLS,
        'merge',
        '-header',
        '-i', 'stdin'
    ]

    log.debug('Starting Bedtools merge: {}'.format(' '.join(cmd_args)))

    temp = tempfile.NamedTemporaryFile()
    bedtools = subprocess.Popen(cmd_args, stdout=temp, stdin=bedtools_sort.stdout)
    bedtools.wait()

    if bedtools.returncode != 0:
        raise ChildProcessError(' '.join(bedtools.args))

    return temp


def bedtools_slop(bed, genome, b=100):
    """ bed can be path to a BED/GFF/VCF """
    cmd_args = [
        BEDTOOLS,
        'slop',
        '-b', str(b),
        '-header',
        '-i', bed,
        '-g', genome
    ]

    log.debug('Starting Bedtools slop: {}'.format(' '.join(cmd_args)))

    temp = tempfile.NamedTemporaryFile()
    bedtools = subprocess.Popen(cmd_args, stdout=temp)
    bedtools.wait()

    if bedtools.returncode != 0:
        raise ChildProcessError(' '.join(bedtools.args))

    return temp


def gtf_to_bed(path):
    exon_bed = tempfile.NamedTemporaryFile()
    ints = intervals.read_gffv2(path)
    ints = ints.filter(lambda i: i['feature'] == 'exon')  # Select only exons
    with open(exon_bed.name, 'w') as fp:
        fp.write(intervals.to_bed(ints))
    return exon_bed


def make_vcf_filter(targets, refdict, gtf):
    # A: Make an exon bed file from the GTF
    exon_bed = gtf_to_bed(gtf)

    # B: Make padded bed for generating filter files
    genome_file = refdict_to_bedtools_genome(refdict)
    padded_targets = bedtools_slop(bed=targets, genome=genome_file.name, b=100)

    # C: Intersection A and B, keep A
    exons_in_targets = bedtools_intersect(exon_bed.name, padded_targets.name)

    # D: Generate Union of A and C
    # This is ugly, here is what it would look like in bash:
    # "cmd = 'cat {padded_targets} {exons_in_targets} | {BEDTOOLS} sort -i stdin
    # | {BEDTOOLS} merge -i {} > {union}'"

    all_ints = tempfile.NamedTemporaryFile()
    with open(all_ints.name, 'w') as all_ints_fp:
        with open(padded_targets.name, 'r') as padded_targets_fp:
            for line in padded_targets_fp:
                all_ints_fp.write(line)
        with open(exons_in_targets.name, 'r') as exons_in_targets_fp:
            for line in exons_in_targets_fp:
                all_ints_fp.write(line)
    union = bedtools_merge(all_ints.name)

    return union


def make_cna_filter(cna_template_bed, bed):
    # First we need to changed X -> 24 and Y -> 25
    bed = intervals.read_bed(bed)
    for i in bed:
        if i['seqname'] == 'X':
            i['seqname'] = '24'
        elif i['seqname'] == 'Y':
            i['seqname'] = '25'

    temp_bed = tempfile.NamedTemporaryFile()
    with open(temp_bed.name, 'w') as fp:
        print(intervals.to_bed(bed), file=fp)

    cmd_args = [
        BEDTOOLS,
        'intersect',
        '-header',
        '-c',
        '-a', cna_template_bed,
        '-b', temp_bed.name
    ]

    log.debug('Starting Bedtools intersect count: {}'.format(' '.join(cmd_args)))

    temp = tempfile.NamedTemporaryFile()
    bedtools = subprocess.Popen(cmd_args, stdout=temp)
    bedtools.wait()

    if bedtools.returncode != 0:
        raise ChildProcessError(' '.join(bedtools.args))

    return temp


def save_tempfile(tempfile, path):
    log.debug('Saving: {} to: {}'.format(tempfile.name, path))

    if os.path.exists(path):
        raise OSError("{} already exists".format(path))
    else:
        with open(tempfile.name, 'r') as temp_fp:
            with open(path, 'w') as fp:
                for line in temp_fp:
                    fp.write(line)


def main(baits, targets, refdict, gtf, cna_template):
    # Make Picard targets/baits interval list files
    picard_targets_intervals = make_picard_intervals_list(targets, refdict)
    if baits is not None:
        picard_baits_intervals = make_picard_intervals_list(baits, refdict)

    # Make VCF bed file
    vcf_filter = make_vcf_filter(targets, refdict, gtf)

    # Make CNA bed file
    cna_filter = make_cna_filter(cna_template, vcf_filter.name)


    # Now save the targets/baits
    targets_dp = DeconstructedPath(targets)
    targets_out = os.path.join(targets_dp.dir, targets_dp.root + '.interval_list')
    save_tempfile(picard_targets_intervals, targets_out)

    if baits is not None:
        baits_dp = DeconstructedPath(baits)
        baits_out = os.path.join(baits_dp.dir, baits_dp.root + '.interval_list')
        save_tempfile(picard_baits_intervals, baits_out)

    # Save VCF bed file
    vcf_filter_out = os.path.join(targets_dp.dir, targets_dp.root + '.filter.bed')
    save_tempfile(vcf_filter, vcf_filter_out)

    # Save CNA bed file
    cna_filter_out = os.path.join(targets_dp.dir, targets_dp.root + '.cna.bed')
    save_tempfile(cna_filter, cna_filter_out)


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    args = parse_args()
    main(**vars(args))
