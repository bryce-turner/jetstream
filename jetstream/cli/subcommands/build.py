"""Build workflow files.

This command will build a finalized workflow and save it to the out path. This
does not run the workflow. It can also be used for converting workflow files to
different formats by setting ``--mode workflow``.

--mode

    This option controls how the workflow will be loaded

    - template (default): build and run a workflow from a template
    - module: build and run a workflow from a Python module
    - workflow: load a pre-existing workflow

"""
import textwrap
import logging
import argparse
import jetstream
from jetstream.cli import shared

log = logging.getLogger(__name__)


def arg_parser():
    parser = argparse.ArgumentParser(
        prog='jetstream build',
        description=__doc__.replace('``', '"'),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        'path',
        help='Path to a template, module, or workflow'
    )

    parser.add_argument(
        'out',
        help='Path to save the workflow file'
    )

    parser.add_argument(
        '--project',
        default='',
        type=shared.set_project,
        help='If the cwd is a project, it will always be loaded. Otherwise,'
             'a path to a project can be specified, and the run will start'
             'in that project directory.'
    )

    parser.add_argument(
        '--mode',
        choices=['template', 'module', 'workflow'],
        default='template',
        help='Run modes, see the descriptions below.'
    )

    template = parser.add_argument_group(
        title='Template Mode',
        description=textwrap.dedent("""\
        To render the template, a config object will be generated by loading
        variables from four places. The precedence for duplicate variables is
        last-value-wins. Project variables will only be loaded when working
        inside a project: 

        1) Current project config file: ``<project>/jetstream/config.yaml``
        2) Any files in: ``<project>/config/`` 
        3) Variables in Json/Yaml file loaded from ``--variables``
        4) Config variables given by ``--<type>:<key> <value>`` arguments

        """)
    )

    template.add_argument(
        '--variables',
        type=jetstream.utils.yaml_load,
        default={},
        help='Load a several variables from a file (json or yaml). Variables '
             'can be loaded individually with arguments in the form: '
             '``--<type>:<key> <value>`` '
    )

    template.add_argument(
        '--kvarg-separator',
        help='Set an alternate separator for kvargs'
    )

    mod = parser.add_argument_group(
        title='Module Mode',
        description=textwrap.dedent("""\
        Not ready yet
        """)
    )

    workflow = parser.add_argument_group(
        title='Workflow Mode',

    )

    workflow.add_argument(
        '--workflow-format',
        choices=[None, 'yaml', 'json', 'pickle'],
        default=None,
        help='Set the workflow file format instead of using the file '
             'extension.'
    )

    return parser


def render_template(path, variables, project):
    """Load the template, render with variables (including project) and
    return the workflow."""
    if project:
        project.config.update(variables)
        project.save_config()  # TODO Do we always want to save the updates?
        wf = jetstream.render_template(path, project.config)
    else:
        wf = jetstream.render_template(path, variables)
    return wf


def main(args=None):
    parser = arg_parser()
    args, remaining = parser.parse_known_args(args)
    kvargs = shared.parse_kvargs(remaining)
    args.variables.update(kvargs)
    log.debug(args)

    if args.mode == 'template':
        workflow = render_template(args.path, args.variables, args.project)
    elif args.mode == 'module':
        raise NotImplementedError
    else:
        workflow = jetstream.load_workflow(args.path, args.workflow_format)

    if args.project:
        wf = args.project.workflow()
        wf.compose(workflow)
        workflow = wf

    workflow.save(path=args.out)


if __name__ == '__main__':
    main()
