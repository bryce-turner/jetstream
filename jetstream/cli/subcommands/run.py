"""Run Jetstream from a template, module, or workflow.

Template Variable Data:

To render the template, a config object will be generated by loading
variables from the current project (when working inside a project) and command
args. The priority order for template variables is as follows:

1) Config variables given by command arguments: ``--<type>:<key> <value>``
2) Current project config file: ``<project>/jetstream/config.yaml``


Detailed argument help:

--mode

    This option controls how the workflow will be loaded

    - template (default): build and run a workflow from a template
    - module: build and run a workflow from a Python module
    - workflow: load and run a pre-built workflow


--reset-method

    This option controls which tasks will be reset when the runner starts

    - retry (default): all pending and failed tasks will be reset
    - resume: all pending tasks will be reset
    - reset: all tasks will be reset

"""
import logging
import argparse
import jetstream

log = logging.getLogger(__name__)


def arg_parser():
    parser = argparse.ArgumentParser(
        prog='jetstream run',
        description=__doc__.replace('``', '"'),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        'path',
        help='Path to a workflow template, python module, or workflow file'
    )

    parser.add_argument(
        '--backend',
        help='Specify the runner backend used for executing tasks'
    )

    parser.add_argument(
        '--build-only',
        action='store_true',
        help='Just render the template, build the workflow, and stop. This '
             'can be used to validate a template and data prior to running.'
    )

    parser.add_argument(
        '--mode',
        choices=['template', 'module', 'workflow'],
        default='template',
        help='Run modes, see the descriptions below.'
    )

    parser.add_argument(
        '-o', '--out',
        default=None,
        help='Path to save the workflow file after it is built. Only used'
             'if running with "--build-only"'
    )

    parser.add_argument(
        '--project',
        help='If the cwd is a project, it will be loaded automatically. '
             'Otherwise, a path to a project can be specified, and the run '
             'will start in that project directory.'
    )

    parser.add_argument(
        '--run-id',
        help='Give this run a specific ID instead of randomly generating one.'
    )

    parser.add_argument(
        '--reset-method',
        choices=['retry', 'resume', 'reset'],
        default=None,
        help='Method to use when running existing workflows. This parameter '
             'will determine which tasks are reset prior to starting the run.'
    )

    parser.add_argument(
        '--workflow-format',
        choices=['yaml', 'json', 'pickle'],
        help='Set the workflow file format instead of guessing from the file '
             'extension.'
    )

    return parser


def main(args=None):
    parser = arg_parser()
    args, remaining = parser.parse_known_args(args)
    log.debug(args)

    try:
        project = jetstream.Project(args.project)
        log.info(f'Working in {project}')
    except jetstream.NotAProject:
        project = None
        log.info('Not working inside of a project!')

    if args.mode == 'template':
        c = jetstream.context(project=project, kvargs=remaining)
        workflow = jetstream.render_template(path=args.path, context=c)
    elif args.mode == 'module':
        raise NotImplementedError
    else:
        workflow = jetstream.load_workflow(args.path, args.workflow_format)

    if project:
        existing_wf = project.workflow()

        if existing_wf is not None:
            workflow = jetstream.workflows.mash(existing_wf, workflow)

    if args.build_only:
        if args.out:
            workflow.save(args.out)
        return

    if args.reset_method == 'retry':
        workflow.retry()
    elif args.reset_method == 'resume':
        workflow.resume()
    elif args.reset_method == 'reset':
        workflow.reset()
    elif args.reset_method is None:
        pass
    else:
        raise ValueError(f'Unrecognized task reset method: {args.reset_method}')

    if args.backend:
        backend = jetstream.utils.dynamic_import(args.backend)
    else:
        backend = None

    runner = jetstream.Runner(backend=backend)
    runner.start(workflow=workflow, project=project, run_id=args.run_id)


if __name__ == '__main__':
    main()
