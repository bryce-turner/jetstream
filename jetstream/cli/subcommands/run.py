"""Run Jetstream from a template, module, or workflow.

--mode

    This option controls how the workflow will be loaded

    - template (default): build and run a workflow from a template
    - module: build and run a workflow from a Python module
    - workflow: load a pre-existing workflow


--method

    This option controls which tasks will be reset when the runner starts

    - retry (default): all pending and failed tasks will be reset
    - resume: all pending tasks will be reset
    - reset: all tasks will be reset

"""
import textwrap
import logging
import argparse
import jetstream
from jetstream.cli import shared
from jetstream.backends import LocalBackend, SlurmBackend

log = logging.getLogger(__name__)


def arg_parser():
    parser = argparse.ArgumentParser(
        prog='jetstream run',
        description=__doc__.replace('``', '"'),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        'path',
        help='Path to a template, module, or workflow'
    )

    parser.add_argument(
        '--project',
        default='',
        type=shared.set_project,
        help='If the cwd is a project, it will be loaded automatically. '
             'Otherwise, a path to a project can be specified, and the run '
             'will start in that project directory.'
    )

    parser.add_argument(
        '--mode',
        choices=['template', 'module', 'workflow'],
        default='template',
        help='Run modes, see the descriptions below.'
    )

    parser.add_argument(
        '--no-check',
        action='store_false',
        default=True,
        dest='check_workflow',
        help='Ignore failed tasks after run. Runtime errors (problems '
             'launching tasks, or runner errors) will still cause a non-zero '
             'exit status. '
    )

    template = parser.add_argument_group(
        title='Template Mode',
        description=textwrap.dedent("""\
        To render the template, a config object will be generated by loading
        variables from four places. The precedence for duplicate variables is
        last-value-wins. Project variables will only be loaded when working
        inside a project: 
        
        1) Current project config file: ``<project>/jetstream/config.yaml``
        2) Any files in: ``<project>/config/`` 
        3) Variables in Json/Yaml file loaded from ``--variables``
        4) Config variables given by ``--<type>:<key> <value>`` arguments
        
        """)
    )

    template.add_argument(
        '--variables',
        type=shared.load_variables,
        default={},
        help='Load a several variables from a file (json or yaml). Variables '
             'can be loaded individually with arguments in the form: '
             '``--<type>:<key> <value>`` '
    )

    template.add_argument(
        '--kvarg-separator',
        help='Set an alternate separator for kvargs variables'
    )

    mod = parser.add_argument_group(
        title='Module Mode',
        description=textwrap.dedent("""\
        Not ready yet
        """)
    )

    workflow = parser.add_argument_group(
        title='Workflow Mode',

    )

    workflow.add_argument(
        '--workflow-format',
        choices=[None, 'yaml', 'json', 'pickle'],
        default=None,
        help='Set the workflow file format instead of using the file '
             'extension.'
    )

    runner = parser.add_argument_group(
        title='Runner Configuration'
    )

    runner.add_argument(
        '--save-interval',
        type=int,
        default=3600,
        help='Frequency, in seconds, that the workflow file will be saved to '
             'disk. (Default: 3600)')

    runner.add_argument(
        '--backend',
        choices=['local', 'slurm'],
        default='slurm',
        help='Specify the runner backend (Default: local)'
    )

    runner.add_argument(
        '--local',
        dest='backend',
        action='store_const',
        const='local'
    )

    runner.add_argument(
        '--slurm',
        dest='backend',
        action='store_const',
        const='slurm'
    )

    runner.add_argument(
        '--run-id',
        help='Give this run a specific ID instead of randomly generating one.'
    )

    runner.add_argument(
        '--max-forks',
        default=None,
        type=int,
        help='Override the default fork limits of the runner. By default, '
             'this will be set to a conservative fraction of the total thread '
             'limit on runner host.')

    runner.add_argument(
        '--method',
        choices=['retry', 'resume', 'reset'],
        default='retry',
        help='Method to use when running existing workflows. This parameter '
             'will determine which tasks are reset prior to starting the run.'
    )

    return parser


def main(args=None):
    parser = arg_parser()
    args, remaining = parser.parse_known_args(args)
    kvargs = shared.parse_kvargs(remaining)
    args.variables.update(kvargs)
    log.debug(args)

    if args.mode == 'template':
        workflow = jetstream.render_template(
            path=args.path,
            variables=args.variables,
            project=args.project
        )
    elif args.mode == 'module':
        raise NotImplementedError
    else:
        workflow = jetstream.load_workflow(args.path, args.workflow_format)

    if args.project:
        args.variables.update(project=args.project)
        wf = args.project.workflow()
        wf.compose(workflow)
        workflow = wf

    if args.method == 'retry':
        workflow.retry()
    elif args.method == 'resume':
        workflow.resume()
    elif args.method == 'reset':
        workflow.reset()

    if args.backend == 'slurm':
        backend = SlurmBackend
    else:
        backend = LocalBackend

    runner = jetstream.Runner(
        backend=backend,
        max_forks=args.max_forks,
        autosave=args.save_interval,
    )

    runner.start(
        workflow=workflow,
        project=args.project,
        run_id=args.run_id,
    )


if __name__ == '__main__':
    main()
