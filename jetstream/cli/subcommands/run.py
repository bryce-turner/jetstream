"""Run Jetstream from a template, module, or workflow


Template Rendering:

To render the template, a config object will be generated by loading
variables from the current project (when working inside a project) and command
args. The priority order for template variables is as follows:

1) Config variables given by command arguments: ``--<type>:<key> <value>``
2) Current project config file: ``<project>/jetstream/config.yaml``

"""
import argparse
import logging
import jetstream
from jetstream.cli import add_config_options_to_parser
from jetstream.templates import render_template_file, render_template_string

log = logging.getLogger(__name__)


def arg_parser(parser):
    parser.add_argument(
        'path',
        help='Path to a workflow template, python module, or workflow file.'
             'If using "pipelines" command, the name of the pipeline'
    )

    parser.add_argument(
        '--backend',
        help='Specify the runner backend used for executing tasks'
    )

    parser.add_argument(
        '--build-only',
        action='store_true',
        help='Just render the template, build the workflow, and stop. This '
             'can be used to validate a template and data prior to running.'
    )

    parser.add_argument(
        '--render-only',
        action='store_true',
        help='Just render the template and stop. This can be used to validate '
             'a template and data prior to running.'
    )

    parser.add_argument(
        '--format',
        choices=['template', 'module', 'workflow'],
        default=None,
        help='Workflow format. If this is not provided, it will be inferred '
             'from the extension of the path.'
    )

    parser.add_argument(
        '-o', '--out',
        default=None,
        help='Path to save the workflow file after it is built. Only used '
             'if running with "--build-only" or "--render-only"'
    )


    parser.add_argument(
        '--reset-method',
        choices=['retry', 'resume', 'reset'],
        default='retry',
        help='Controls which tasks are reset prior to starting the run: '
             'retry(default): pending and failed, resume: pending, reset: all'
    )

    parser.add_argument(
        '--run-id',
        help='Give this run a specific ID instead of randomly generating one'
    )

    parser.add_argument(
        '--workflow-format',
        choices=['yaml', 'json', 'pickle'],
        help='Set the workflow file format instead of guessing from the file '
             'extension.'
    )

    parser.add_argument(
        '--pipeline',
        help=argparse.SUPPRESS
    )

    add_config_options_to_parser(parser)
    return parser


def _resolve_format(args):
    """Guess the workflow format based on the path extension"""
    if args.format is None:
        if args.path.endswith('.pickle'):
            args.format = 'workflow'
        elif args.path.endswith('.py'):
            args.format = 'module'
        else:
            args.format = 'template'


def _load_workflow_from_template(args):




def build():
    started = datetime.now()

    try:
        tasks = jetstream.utils.yaml_loads(render)

        if isinstance(tasks, dict):
            kwargs = tasks
            tasks = tasks.pop('tasks')
        else:
            kwargs = {}

        wf = build_workflow_from_raw_tasks(tasks, **kwargs)
    except Exception:
        tb = traceback.format_exc()
        msg = f'\n{textwrap.indent(tb, "  ")}\n' \
              f'There was an error while creating the workflow.\n' \
              f'See the traceback above for more details. '
        raise ValueError(msg) from None

    elapsed = datetime.now() - started
    log.debug(f'Workflow ready (after {elapsed}): {wf}')


def main(args):
    log.debug(f'{__name__} {args}')
    # Get the runner setup first so that we find errors here before spending
    # time building the workflow
    cls, params = jetstream.lookup_backend(args.backend)
    runner = jetstream.Runner(cls, params)


    # Setup the workflow, this can be built from a template, python module, or
    # loaded from a file.
    _resolve_format(args)

    if args.format == 'template':
        render = jetstream.templates.render_template_file(
            path=args.path,
            project=args.project,
            pipeline=args.pipeline

        )
        if args.render_only:
            return print(workflow)
    elif args.format == 'module':
        raise NotImplementedError
    else:
        workflow = jetstream.load_workflow(args.path, args.workflow_format)

    if args.project:
        try:
            existing_wf = args.project.get_workflow()
            workflow = jetstream.workflows.mash(existing_wf, workflow)
        except FileNotFoundError:
            pass

    workflow.reset(args.reset_method)

    if args.build_only:
        if args.out:
            workflow.save(args.out)
        return print(workflow)

    runner.start(workflow, run_id=args.run_id, project=args.project)
