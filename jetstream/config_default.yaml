# ============================== Jetstream ====================================
# Set the logging style. If this is null, the best logger will be chosen from
# the logging profiles below. You can also define custom profiles, see more
# info below.
log: null

# Set the default backend. Choose from the options listed in settings.backends
backend: local

# Controls the amount of time that the Project object will wait for a project
# to be unlocked
lock_timeout: 60

# If this is set to false, utils.dynamic_import will only search builtins when
# loading functions
dynamic_import: true

# Sets up the loader functions that jetstream.utils.load_file will use for
# auto loading files based on extension
load_file:
  txt: jetstream.utils.load_table
  csv: jetstream.utils.load_table
  mer: jetstream.utils.load_table
  tsv: jetstream.utils.load_table
  json: jetstream.utils.load_json
  yaml: jetstream.utils.load_yaml
  yml: jetstream.utils.load_yaml


# =================================== Runner ==================================
runner:
  max_concurrency: null
  throttle: 0.1
  autosave_min: 5
  autosave_max: 60


# ================================== Backends =================================
backends:
  local:
    (): jetstream.backends.local.LocalBackend
    blocking_io_penalty: 30
    cpus: null
  slurm:
    (): jetstream.backends.slurm.SlurmBackend
    sacct_frequency: 10


# ================================== Pipelines ================================
# Change pipelines:home in order to use the pipelines feature
pipelines:
  home: null


# =================================== Templates ===============================
# Templates are a method for building workflows from text documents. In order
# to recycle a workflow for several project, variables can be used to add
# dynamic features. The value of these variables will be loaded for rendering
# the template prior to a run. Variables will be loaded from this config file
# first, followed by user config files, and ultimately from special command-line
# arguments called kvargs (more on those below). The last value loaded for a
# variable will be whats used to render the template.
#
# Kvargs are arbitrary keyword arguments that include an explicit type
# declaration. Jetstream uses kvargs to load variable data when rendering
# templates. The format for kvargs is "--<type><separator><key> <value>". These
# settings determine how kvargs will be handled and which functions will be
# used for a given argument type.
#
# If allow_dynamic_import is true, loaders will imported dynamically.
# Otherwise, only the builtins module will be searched for a loader function.
#
constants:
  foo: bar

kvargs:
  allow_dynamic_import: true
  separator: ":"
  loaders:
    str: str
    int: int
    float: float
    bool: jetstream.utils.parse_bool
    json: jetstream.utils.json_loads
    yaml: jetstream.utils.yaml_loads
    url: urllib.parse.urlparse
    uri: urllib.parse.urlparse
    file: jetstream.utils.load_file


# ================================== Logging ==================================
# To permanently force a single logging style, create a key in your user
# config like this:
#
#   logging: <profile name>
#
# Each key under logging_profiles is a mapping that meets the dictionary
# configuration requirements for the logging module.
# To create a new logging profile, create a new key under the logging_profiles
# section of your user config, the value should be a mapping that meets the
# Python logging dict config schema.
# See: https://docs.python.org/3.7/library/logging.config.html
# Example:
#
# logging_profiles:
#   <profile_name>:
#      version: 1  # Required for future backwards-compatibility
#      # Everything below here follows the Python logging dict config schema
#      formatters:
#        f:
#          format: "[{module}] {asctime}: {message}"
#          datefmt: "%Y-%m-%d %H:%M:%S"
#          style: "{"
#      handlers:
#        h:
#          class: logging.StreamHandler
#          level: INFO
#          formatter: f
#      loggers:
#        jetstream:  # Jetstream modules are all children of this logger
#          level: INFO
#          handlers: [h]
#
logging_profiles:
  silent:
    version: 1
  default:
    version: 1
    formatters:
      f:
        format: '[{module}] {asctime}: {message}'
        datefmt: '%Y-%m-%d %H:%M:%S'
        style: '{'
    handlers:
      h:
        class: logging.StreamHandler
        level: INFO
        formatter: f
    loggers:
      jetstream:
        level: INFO
        handlers: [h]
  debug:
    version: 1
    formatters:
      f:
        format: '{module}:{lineno} {levelname} {asctime}:{message}'
        datefmt: '%Y-%m-%d %H:%M:%S'
        style: '{'
    handlers:
      h:
        class: logging.StreamHandler
        level: DEBUG
        formatter: f
    loggers:
      jetstream:
        level: DEBUG
        handlers: [h]
  interactive:
    version: 1
    formatters:
      f:
        format: "[\x1b[4m\x1b[92m\U0001F335 {module:>10}\x1b[0m] {asctime}: {message}"
        datefmt: '%Y-%m-%d %H:%M:%S'
        style: '{'
    handlers:
      h:
        class: logging.StreamHandler
        level: INFO
        formatter: f
    loggers:
      jetstream:
        level: INFO
        handlers: [h]


# =============================== Notifications ===============================
# Notification settings control how the runner should alert users when
# certain events occur. Here are some examples
#
# notifications:
#  slack:
#    on: [run-fail, task-fail,]
#    credentials:
#
#  email:
#    on: [run-fail, run-complete]
#    host: localhost
#    port: 0
#    from_addrs: ''
#    to_addrs: []  # Project email addresses will be added to this list
#    msg: |
#      <h1>Jetstream Notice for {{ runner.run_id }}</h1>
#
#      {# this will be formatted with the current run context available #}
#      <p>{{ message }}</p>
notifications: null
