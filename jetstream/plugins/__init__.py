""" Establish a plugin registry to allow a variety of plugin flavors to be used
in workflows.

A uniform description of the plugins themselves needs to be recorded somewhere.
This could be generated by the developer each time a plugin is added, a
corresponding record is added to the table. But, it would be better if these
records were generated from the codebase itself.

For python-package plugins it's easy, just define a set of values that need to be
included in __init__. For script plugins it's much harder because we don't read
them at runtime, they're just executed. We could require a manifest.json be
included along with each script? Or this utility pulls plugins from a central
 location that also warehouses the manifests?


Uses some advanced glob for stageIn/stageOut

Plugin id format:
    "{}/{}:{}".format(plugin, path, revision (optional))

The tools here can be combined for some pretty cool results. Here is a loop that
prints every version of a plugin component available in the archive:

```python
for r in plugins.list_revisions('pegasusPipe/jobScripts/pegasus_firstStrandedSalmon.sh'):
     p = plugins.get_plugin('pegasusPipe/jobScripts/pegasus_firstStrandedSalmon.sh'+ ':'+r['id'])
     print('pegasusPipe/jobScripts/pegasus_firstStrandedSalmon.sh'+ ':'+r['id'])
     print(p.decode())
```

"""
import os
import re
import shutil
import subprocess
import glob
import logging

from jetstream import utils, PLUGIN_DIR, PLUGIN_ID_PATTERN

log = logging.getLogger(__name__)


class PluginParserFail(Exception):
    """ Raised when a plugin is found but does not pass validation """

class PluginLookup(Exception):
    """ Raised when plugin is not found """

class InvalidPluginId(Exception):
    """ Raised when a plugin id does not match format """


def _clone(repo='https://github.com/tgen/pegasusPipe.git'):
    # TODO Validate that the repo we want is actually a jetstream plugin repo
    # not sure yet about the best place to do this. Jetstream plugin repo is
    # a collection of yaml files that describe plugins, we don't want to try
    # loading files that are not plugins etc..
    log.critical('Cloning {} into {}'.format(repo, PLUGIN_DIR))
    subprocess.run(
        ['git', 'clone', repo],
        cwd=PLUGIN_DIR
    )


def _remove(plugin):
    """ Careful, this is essentially a shortcut to rm -rf """
    shutil.rmtree(os.path.join(PLUGIN_DIR, plugin))


def _get_path(plugin, path, revision):
    """ Retrieve a path from plugin. Returns the path as bytes.

    This function translates its parameters into a 'git show' command
    in order to pull scripts from the archival git repo. The most recent
    version of the path will be returned if "revision" is None. This will
    raise a PluginLookup exception if the path does not exist.

    """
    identifier = '{}:{}'.format(revision, path)
    try:
        p = subprocess.Popen(
            ['git', 'show', identifier],
            cwd=os.path.join(PLUGIN_DIR, plugin),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
    except FileNotFoundError:
        raise FileNotFoundError('Cant launch git executable') from None

    stdout, stderr = p.communicate()

    if p.returncode != 0:
        raise PluginLookup(stderr.decode())

    return stdout.decode()


def _get_path_revisions(plugin, path):
    """ Returns a list of all the logs for a particular path.
   It may be useful at some point for discovering versions available.
   http://blog.lost-theory.org/post/how-to-parse-git-log-output/
   """
    commit_fields = ['id', 'author_name', 'author_email', 'date', 'message']
    log_fields = ['%H', '%an', '%ae', '%ad', '%s']
    git_log_format = '%x1f'.join(log_fields) + '%x1e'
    format_flag = '--format={}'.format(git_log_format)

    data = subprocess.check_output(
        ['git', 'log', format_flag, '--', path],
        cwd=os.path.join(PLUGIN_DIR, plugin)
    ).decode()

    git_log = data.strip('\n\x1e').strip().split('\x1e')
    git_log = [row.strip().split('\x1f') for row in git_log]
    git_log = [dict(zip(commit_fields, row)) for row in git_log]

    return git_log


def _load_plugin_from_data(data):
    # TODO This is the only plugin validation, do we need more?
    try:
        plugin = utils.load_yaml_data(data)
    except utils.yaml.YAMLError as err:
        raise PluginParserFail(str(err)) from None

    try:
        assert plugin['script']
    except AssertionError:
        raise PluginParserFail('"script" not found in plugin data')

    return plugin


def plugin_id(plugin, path, revision, **kwargs):
    """ Returns a string formatted plugin id from a set of parameters. This
    can called with only a mapping that includes the required keys:
    plugin_id(**mapping) """
    return "{}/{}:{}".format(plugin, path, revision)


def parse_plugin_id(string):
    """ Resolves a plugin id string, returns tuple:(plugin, path, revision)"""
    pat = re.compile(PLUGIN_ID_PATTERN)

    match = pat.match(string)
    if match is None:
        raise InvalidPluginId(string)
    else:
        g = match.groupdict()
        return (g.get('plugin'), g.get('path'), g.get('revision'))


def list():
    """ List all plugin paths available """
    all = glob.glob(PLUGIN_DIR + '/**', recursive=True)
    all = [p for p in all if os.path.isfile(p)]
    all = [utils.remove_prefix(p, PLUGIN_DIR) for p in all]
    all = [p for p in all if p and not p.startswith(('_', 'README'))]
    return all


def list_revisions(plugin_id):
    """ Given a plugin id, returns a list of all revisions """
    plugin, path, revision = parse_plugin_id(plugin_id)
    revs = _get_path_revisions(plugin, path)
    return revs


def latest_revision(plugin_id):
    """ Given plugin id, returns the latest revision as a complete plugin
     id string """
    plugin, path, _ = parse_plugin_id(plugin_id)
    revs = _get_path_revisions(plugin, path)
    return revs[0]['id']


def get_plugin(plugin_id):
    """ Given plugin_id returns loaded the plugin object.
    If the plugin_id does not contain revision information, the latest
    revision will be returned. """
    plugin, path, revision = parse_plugin_id(plugin_id)  # Validate the id

    if revision is None:
        revision = latest_revision(plugin_id)

    plugin_data = _get_path(plugin, path, revision)  # lookup id in repo

    plugin_obj = _load_plugin_from_data(plugin_data)  # Parse data pulled from repo
    plugin_obj['plugin'] = plugin  # Add some extra identifiers
    plugin_obj['path'] = path
    plugin_obj['revision'] = revision

    return plugin_obj


def is_available(plugin_id):
    try:
        get_plugin(plugin_id)
        return True
    except (FileNotFoundError, ValueError, ChildProcessError):
        return False
