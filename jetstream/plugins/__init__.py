""" Establish a plugin registry to allow a variety of plugin flavors to be used
in workflows.

A uniform description of the plugins themselves needs to be recorded somewhere.
This could be generated by the developer each time a plugin is added, a
corresponding record is added to the table. But, it would be better if these
records were generated from the codebase itself.

For python-package plugins it's easy, just define a set of values that need to be
included in __init__. For script plugins it's much harder because we don't read
them at runtime, they're just executed. We could require a manifest.json be
included along with each script? Or this utility pulls plugins from a central
 location that also warehouses the manifests?


Uses some advanced glob for stageIn/stageOut

Plugin id format:
    "{}/{}:{}".format(plugin, path, revision (optional))

The tools here can be combined for some pretty cool results. Here is a loop that
prints every version of a plugin component available in the archive:

```python
for r in plugins.list_revisions('pegasusPipe/jobScripts/pegasus_firstStrandedSalmon.sh'):
     p = plugins.get_plugin('pegasusPipe/jobScripts/pegasus_firstStrandedSalmon.sh'+ ':'+r['id'])
     print('pegasusPipe/jobScripts/pegasus_firstStrandedSalmon.sh'+ ':'+r['id'])
     print(p.decode())
```

"""
import os
import re
import shutil
import subprocess
import logging

from jetstream import utils, PLUGIN_DIR, PLUGIN_ID_PATTERN

log = logging.getLogger(__name__)

log.debug('Plugin dir: {}'.format(PLUGIN_DIR))

class PluginParserFail(Exception):
    """ Raised when a plugin is found but does not pass validation """


class PluginLookup(Exception):
    """ Raised when plugin is not found """


class InvalidPluginId(Exception):
    """ Raised when a plugin id does not match format """


def clone(repo):
    """ Attempts to clone a plugin repository. This will raise
    subprocess.CalledProcessError if the requested plugin is not found.
    And FileNotFound if git is not installed. """
    if repo.startswith(('https', 'git@github.com')):
        pass
    else:
        repo = os.path.realpath(repo)

    cmd_args = ['git', 'clone', '--bare', repo]

    # TODO Validate that the repo we want is actually a jetstream plugin repo
    # not sure yet about the best place to do this. Jetstream plugin repo is
    # a collection of yaml files that describe plugins, we don't want to try
    # loading files that are not plugins etc..

    log.debug('Launching "{}" in "{}"'.format(' '.join(cmd_args), PLUGIN_DIR))
    subprocess.check_call(cmd_args, cwd=PLUGIN_DIR)


def plugins():
    """Generator that yields paths in PLUGIN_DIR if they 1) are directories
     and 2) end with '.git' """
    for plugin in os.listdir(PLUGIN_DIR):
        git_repo = os.path.join(PLUGIN_DIR, plugin)
        if git_repo.endswith('.git') and os.path.isdir(git_repo):
            yield utils.remove_prefix(plugin, PLUGIN_DIR)


def components():
    """Generator that yields components in all plugins as returned by plugins()
    """
    cmd_args = ['git', 'ls-tree', '--full-tree', '-r', '--name-only', 'HEAD']
    for p in plugins():
        repo_path = os.path.join(PLUGIN_DIR, p)
        log.debug(
            'Launching "{}" in "{}"'.format(' '.join(cmd_args), repo_path))
        paths = subprocess.check_output(cmd_args, cwd=repo_path).decode()
        for f in paths.splitlines():
            yield  os.path.join(p, f)


def ls():
    """Returns a list of all available components"""
    return list(components())


def list_revisions(pid):
    """Given a plugin id, returns a list of all revisions """
    plugin, path, revision = parse_plugin_id(pid)
    revs = _get_path_revisions(plugin, path)
    return revs


def update():
    cmd_args = ['git', 'fetch', '-q', 'origin', 'master:master']
    cmd_args2 = ['git', 'log', '-1']
    for p in plugins():
        print('Updating {}'.format(p))
        repo_path = os.path.join(PLUGIN_DIR, p)
        log.debug(
            'Launching "{}" in "{}"'.format(' '.join(cmd_args), repo_path))
        subprocess.call(cmd_args, cwd=repo_path)
        print('Latest commit:')
        subprocess.call(cmd_args2, cwd=repo_path)


def remove(plugin):
    """ Careful, this is essentially a shortcut to rm -rf """
    target = os.path.join(PLUGIN_DIR, plugin)
    log.debug('Launching shutil.rmtree on {}'.format(target))
    shutil.rmtree(target)


def _get_path(plugin, path, revision):
    """ Retrieve a path from plugin. Returns the path as bytes.

    This function translates its parameters into a 'git show' command
    in order to pull scripts from the archival git repo. The most recent
    version of the path will be returned if "revision" is None. This will
    raise a PluginLookup exception if the path does not exist.

    """
    identifier = '{}:{}'.format(revision, path)
    cmd_args = ['git', 'show', identifier]
    repo_path = os.path.join(PLUGIN_DIR, plugin)
    log.debug('Launching "{}" in "{}"'.format(' '.join(cmd_args), repo_path))

    if not os.path.isdir(repo_path):
        raise FileNotFoundError('Plugin repo not found {}'.format(repo_path))

    try:
        p = subprocess.Popen(
            cmd_args,
            cwd=repo_path,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
    except FileNotFoundError:
        raise FileNotFoundError('Cant find git executable') from None

    stdout, stderr = p.communicate()

    if p.returncode != 0:
        raise PluginLookup(stderr.decode())

    return stdout.decode()


def _get_path_revisions(plugin, path):
    """ Returns a list of all the logs for a particular path.
   It may be useful at some point for discovering versions available.
   http://blog.lost-theory.org/post/how-to-parse-git-log-output/
   """
    commit_fields = ['id', 'author_name', 'author_email', 'date', 'message']
    log_fields = ['%H', '%an', '%ae', '%ad', '%s']
    git_log_format = '%x1f'.join(log_fields) + '%x1e'
    format_flag = '--format={}'.format(git_log_format)

    cmd_args = ['git', 'log', format_flag, '--', path]
    repo_path = os.path.join(PLUGIN_DIR, plugin)
    log.debug('Launching "{}" in "{}"'.format(' '.join(cmd_args), repo_path))
    data = subprocess.check_output(cmd_args, cwd=repo_path).decode()

    git_log = data.strip('\n\x1e').strip().split('\x1e')
    git_log = [row.strip().split('\x1f') for row in git_log]
    git_log = [dict(zip(commit_fields, row)) for row in git_log]

    return git_log


def _load_plugin_from_data(data):
    # TODO This is the only plugin validation, do we need more?
    if not data:
        raise PluginParserFail('Empty plugin!') from None

    try:
        plugin = utils.yaml_loads(data)
    except utils.yaml.YAMLError as err:
        raise PluginParserFail(str(err)) from None

    try:
        assert plugin['script']
    except AssertionError:
        raise PluginParserFail('"script" not found in plugin data')

    return plugin


def plugin_id(plugin, path, revision, **kwargs):
    """ Returns a string formatted plugin id from a set of parameters. This
    can called with only a mapping that includes the required keys:
    plugin_id(**mapping) """
    return "{}/{}:{}".format(plugin, path, revision)


def parse_plugin_id(string):
    """ Resolves a plugin id string, returns tuple:(plugin, path, revision)"""
    pat = re.compile(PLUGIN_ID_PATTERN)

    match = pat.match(string)
    if match is None:
        raise InvalidPluginId(string)
    else:
        g = match.groupdict()
        return (g.get('plugin'), g.get('path'), g.get('revision'))


def latest_revision(pid):
    """ Given plugin id, returns the latest revision as a complete plugin
     id string """
    plugin, path, _ = parse_plugin_id(pid)
    revs = _get_path_revisions(plugin, path)
    return revs[0]['id']


def get_plugin(pid, script_only=False):
    """ Given plugin_id returns loaded the plugin object.
    If the plugin_id does not contain revision information, the latest
    revision will be returned. """
    if pid.startswith('file://'):
        plugin = revision = None
        path = utils.remove_prefix(pid, 'file://')
        with open(path, 'r') as fp:
            plugin_data = fp.read()
    else:
        plugin, path, revision = parse_plugin_id(pid)  # Validate the id

        if revision is None:
            revision = latest_revision(pid)

        plugin_data = _get_path(plugin, path, revision)

    plugin_obj = _load_plugin_from_data(plugin_data)
    plugin_obj['plugin_id'] = pid
    plugin_obj['plugin'] = plugin
    plugin_obj['path'] = path
    plugin_obj['revision'] = revision
    plugin_obj['freeze'] = plugin_id(plugin, path, revision)

    if script_only:
        return plugin_obj['script']

    return plugin_obj


def is_available(plugin_id):
    try:
        get_plugin(plugin_id)
        return True
    except (FileNotFoundError, ValueError, ChildProcessError):
        return False

