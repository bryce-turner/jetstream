""" Creates a reference package for a new exome capture kit

Three types of files are created:

Picard .interval_lists:

    These are used for Picard metrics modules and describe the locations
    targetted by the capture kit. Coverage metrics generated by the pipeline
    will be relative to the regions defined in these files. There is one
    '.interval_list' for the targets and one for the baits. If baits is
    not given, both files will be generated from the targets.

VCF merger filter .bed:
    This is a bed file that describes the locations to include in the final
    merged VCF. This file is generated by extending regions in the targets
    intervals file for a more comprehensive filter. This file includes a union
    of the following intervals:
        A) All intervals in the targets intervals file padded by 100bp
        B) All exons (from the gene model file) that intersect any A

CNA index .bed:
    This file is an index for tCoNut, in bed format, which describes the
    targeted regions in 100bp intervals. This is generated by intersecting
    a template bed file with the VCF merger filter .bed.

"""
import pkg_resources
import subprocess
import logging
import configparser
import argparse

import jetstream

log = logging.getLogger(__name__)

PICARD_PATH = pkg_resources.resource_filename('jetstream', 'lib/picard.jar')

# TODO: add to readme or help
# https://gatkforums.broadinstitute.org/gatk/discussion/1319/collected-faqs-about-interval-lists
# https://www.ensembl.org/info/website/upload/bed.html
# http://broadinstitute.github.io/picard/command-line-overview.html#BedToIntervalList

def check_java_version():
    log.debug(subprocess.check_output(['java', '-version']))
    return True


def make_picard_intervals_list(bed, ref_dict):
    """ Starts a Picard BedToIntervalList process and returns results """
    cmd_args = [
        'java',
        '-jar',
        PICARD_PATH,
        'BedToIntervalList',
        'I=' + bed,
        'O=/dev/stdout',
        'SD=' + ref_dict,
    ]

    log.debug('Starting Picard: {}'.format(' '.join(cmd_args)))

    picard = subprocess.Popen(
        cmd_args,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )

    picard.wait()

    if picard.returncode != 0:
        err = picard.stderr.read()
        err = err.decode()  # TODO in python2 this will throw an error, not sure which error though
        raise ChildProcessError('{}\n{}'.format(' '.join(picard.args), err))

    return picard.stdout.read().decode('utf8')


def main(baits, targets, gtf, ref_dict):
    check_java_version()


    # Coerce sequence names

    baits = make_picard_intervals_list(baits, ref_dict)

    return baits

    # print('making reference bed')
    # reference_bed = tempfile.NamedTemporaryFile()
    # with open(reference_bed.name, 'w') as fp:
    #     data = bed.make_bed(gtf)
    #     fp.write(data)
    #
    #
    #
    # print(len(picard.stdout.read()))


def parse_args(args=None):
    parser = argparse.ArgumentParser(
        description='Generate targets/baits interval files for Picard and tCoNuT',
        epilog='More information on bed files can be found here:\n'
               'https://www.ensembl.org/info/website/upload/bed.html'
    )

    parser.add_argument(
        '-b', '--baits',
        help='Path to a baits bed file. This file should describe the locations '
             'of the hybrid capture baits/probes in bed format (see below). '
             'Sometimes this file is not available from the manufacturer. In '
             'that case, this option can be omitted and the targets file will '
             'be used instead.'
    )

    parser.add_argument(
        '-t', '--targets',
        required=True,
        help='Path to the targets bed file. This file should describe the '
             'regions covered by your capture kit and should be in bed format '
             '(see below). '
    )

    parser.add_argument(
        '-g', '--gtf',
        required=True,
        help='Path to a reference GTF used for creating the tCoNuT filter '
             'files. This should be compatible with the dictionary given in '
             '"-r/--reference". '
    )

    parser.add_argument(
        '-r', '--reference',
        required=True,
        help="Path to the reference dictionary, can be any of the following: "
             "1) A file with .dict extension generated using Picard's "
             "CreateSequenceDictionaryTool 2) A reference.fa or reference.fasta "
             "file with a reference.dict in the same directory 3) Another "
             "IntervalList with @SQ lines in the header from which to generate "
             "a dictionary 4) A VCF that contains #contig lines from which to "
             "generate a sequence dictionary 5) A SAM or BAM file with @SQ "
             "lines in the header from which to generate a dictionary."
    )

    args = parser.parse_args(args)
    return args


def cli(args=None): #reference_gtf, reference_dict, targets_bed, regions_bed):
    args = parse_args(args)
    baits_gtf = args.baits
    targets_gtf = args.targets
    ref_dict = args.reference


